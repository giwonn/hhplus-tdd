# 동시성 제어 보고서

## 동시성이란
동시성은 여러 작업이 동시에 실행되는것처럼 보이는 상황을 의미합니다.  
이는 CPU에서 여러 스레드를 매우 빠르게 번갈아가며 실행함으로써 동시에 동작하는 것처럼 보이게 합니다.


## 동시성 이슈 발생 원인
동시성 이슈는 주로 공유 자원에 대한 접근이 통제되지 않을 때 발생합니다.  

일반적으로 코드는 여러 연산들의 집합으로 이루어져 있습니다.  
동시성 이슈는 대표적으로 스레드간의 데이터 불일치로 인해 발생합니다.  
스레드가 읽기와 쓰기 등의 작업을 진행하는 도중에 다른 스레드가 공유 자원에 관여하기 때문입니다.  

포인트 사용을 예로 들어보겠습니다.  
포인트를 사용하기 위해서는 `현재 포인트` 및 `사용할 포인트`가 필요합니다.

100 포인트가 남아 있을 때, A 스레드에서 50포인트를 사용하려 합니다.  

A 스레드가 포인트를 사용 요청을 받아 진행하는 과정은 다음과 같습니다.  
```
1. 포인트 조회
2. 조회된 포인트 기준으로 포인트 차감
3. 차감 후의 포인트를 DB에 반영
```
1~3번의 작업의 결과를 보장하려면 이 과정들이 원자적으로 동작하여야 합니다.  
하지만 작업 중간에 Context Switching이 일어나게 된다면, A 스레드는 잠시 중단된 채로 보류되고 다른 스레드가 작업을 진행합니다.

만약 A 스레드와 B 스레드가 동시에 동일 유저에 대해 50포인트씩 사용하는 작업을 한다면 흐름은 이렇게 될 수 있습니다.  
```
1. A 스레드 - 포인트 조회 (100pt)
2. A 스레드 - 50 포인트 사용 (100pt - 50pt)
3. B 스레드 - 포인트 조회 (100pt)
4. B 스레드 - 50 포인트 사용 (100pt - 50pt)
5. A 스레드 - 포인트 반영 (잔여포인트=50pt)
6. B 스레드 - 포인트 반영 (잔여포인트=50pt)
```

100 포인트에서 50포인트씩 두 번 사용하였으니 0포인트가 되어야 합니다.  
하지만 두 스레드가 거의 동일한 시점에 데이터를 조회하고 차감하면서 실제 결과와 달라지게 되었습니다.  


## 동시성 이슈 해결책
**Synchronized 키워드**  
이 키워드는 메서드 단위로 JVM 수준의 Monitor Lock을 지원합니다.  
별다른 조건 없이 메서드에 임계 구역 설정만으로도 충분하다면 이 키워드로 충분합니다.  
하지만 Synchronized 키워드는 락에 대한 공정성 설정이 불가능하다는 단점이 있습니다.  
또한 Lock에 대한 조건을 지정해줄 수 없다는 단점도 있기에 이번 과제에 Synchronized를 고려하지는 않았습니다.  


**ReentrantLock**  
ReentrantLock은 자바에서 지원하는 Lock 중 하나입니다.  
가장 큰 특징은 공정성 설정이 가능하며 Lock의 범위 또한 지정이 가능합니다.  


**ReentrantReadWriteLock**  
ReentrantLock에서 확장된 Lock입니다. 클래스명대로 Read Lock과 Write Lock을 구분하여 관리할 수 있는 락입니다.  
Read Lock은 여러 스레드가 동시에 Lock을 획득 가능합니다.  
Write Lock은 하나의 스레드만 획득 가능하며 Write Lock이 동작중일때는 읽기조차 차단하여 데이터 일관성을 보장해줍니다.  



## 과제 동시성 이슈 해결 방법

과제에서 고려할 조건이 크게 3가지 있었습니다.
1. UserPoint는 User 단위로 저장되는 점
2. PointHistory는 단일 List로 관리되는 점
3. 요청이 들어온 순서대로 제어되어야 함 

### 1. UserPoint
UserPoint에서 각 유저의 정보는 공유 자원이 아니기에 유저별 Lock 관리가 필요하였습니다.  
저는 이를 해결하기 위해 Lock을 관리하는 자료구조로 `ConcurrentHashMap<Long, ReentrantReadWriteLock>`을 이용하였습니다.

- **ConcurrentHashMap을 사용한 이유**  
  HashMap은 Thread-Safe하지 않으며, Key를 추가할 때 해시 테이블 리사이징이 발생할 수 있습니다.  
  이 과정에서 다른 스레드가 자원을 조회하면 정상적으로 Lock을 반환받지 못할 수도 있습니다.  
  ConcurrentHashMap은 내부적으로 락을 사용하여 동시성과 안전성을 제공하므로 현재 상황에 적절하다고 생각하였습니다.  
  
- **ReentrantReadWriteLock을 사용한 이유**  
  UserPointTable은 HashMap 자료구조를 사용하고 있으며, 이 코드는 수정할 수 없는 제약사항이 있었습니다.  
  UserPointTable 또한 테이블 리사이징 이슈가 발생할 수 있기 때문에 읽기 작업에서의 동시성을 보장하고자 하였습니다.  

### 2. PointHistory
PointHistory는 ReentrantReadWriteLock만 사용하였습니다.  
PointHistoryTable의 자료구조인 ArrayList는 Thread-Safe하지 않기 때문에 이를 제어하기 위해 ReentrantReadWriteLock을 사용하였습니다.  


### 3. 작업의 순서 보장
ReentrantReadWriteLock의 공정성 옵션을 사용하여 락을 요청한 순서대로 스레드가 락을 획득하도록 하였습니다. 

